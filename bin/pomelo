#!/usr/bin/env node

/**
 * Module dependencies.
 */
const fs = require('fs');
const os = require('os');
const path = require('path');
const util = require('util');
const cliff = require('cliff');
const mkdirp = require('mkdirp');
const utils = require('../lib/util/utils');
const starter = require('../lib/util/starter');
const exec = require('child_process').exec;
const version = require('../package.json').version;
const constants = require('../lib/util/constants');
const program = require('commander');

const redis=require('ioredis');

/**
 *  Constant Variables
 */
let TIME_INIT = 1 * 1000;
let TIME_KILL_WAIT = 5 * 1000;
let KILL_CMD_LUX = 'kill -9 `ps -ef|grep node|awk \'{print $2}\'`';
let KILL_CMD_WIN = 'taskkill /im node.exe /f';

let CUR_DIR = process.cwd();
let DEFAULT_GAME_SERVER_DIR = CUR_DIR;
let DEFAULT_REDIS_PRE = 'pomelo';
let DEFAULT_PWD = 'admin';
let DEFAULT_ENV = 'development';
let DEFAULT_MASTER_HOST = '192.168.2.12';
let DEFAULT_MASTER_PORT = 6379;

let CONNECT_ERROR = 'Fail to connect to admin console server.';
let FILEREAD_ERROR = 'Fail to read the file, please check if the application is started legally.';
let CLOSEAPP_INFO = 'Closing the application......\nPlease wait......';
let ADD_SERVER_INFO = 'Successfully add server.';
let INIT_PROJ_NOTICE = '\nThe default admin user is: \n\n'+ '  username'.green + ': admin\n  ' + 'password'.green+ ': admin\n\nYou can configure admin users by editing adminUser.json later.\n ';
let SCRIPT_NOT_FOUND = 'Fail to find an appropriate script to run,\nplease check the current work directory or the directory specified by option `--directory`.\n'.red;
let COMMAND_ERROR = 'Illegal command format. Use `pomelo --help` to get more info.\n'.red;
let DAEMON_INFO = 'The application is running in the background now.\n';

program.version(version);

program.command('init [path]')
  .description('create a new application')
  .action(function(path) {
    init(path || CUR_DIR);
  });

program.command('start')
  .description('start the application')
  .option('-e, --env <env>', 'the used environment', DEFAULT_ENV)
  .option('-D, --daemon', 'enable the daemon start')
  .option('-d, --directory, <directory>', 'the code directory', DEFAULT_GAME_SERVER_DIR)
  .option('-t, --type <server-type>,', 'start server type')
  .option('-i, --id <server-id>', 'start server id')
  .action(function(opts) {
    start(opts);
  });

program.command('list')
  .description('list the servers')
  .option('-e, --env <env>', 'the used environment', DEFAULT_ENV)
  .option('-r, --rpre <redis pre>', 'administration user name', DEFAULT_REDIS_PRE)
  .option('-p, --password <password>', 'administration password', DEFAULT_PWD)
  .option('-h, --host <master-host>', 'master server host', DEFAULT_MASTER_HOST)
  .option('-P, --port <master-port>', 'master server port', DEFAULT_MASTER_PORT)
  .action(function(opts) {
    list(opts);
  });

program.command('add')
  .description('add a new server')
  .option('-e, --env <env>', 'the used environment', DEFAULT_ENV)
  .option('-d, --directory, <directory>', 'the code directory', DEFAULT_GAME_SERVER_DIR)
  .action(function() {
    let args = [].slice.call(arguments, 0);
    let opts = args[args.length - 1];
    opts.args = args.slice(0, -1);
    add(opts);
  });

program.command('stop')
  .description('stop the servers, for multiple servers, use `pomelo stop server-id-1 server-id-2`')
  .option('-e, --env <env>', 'the used environment', DEFAULT_ENV)
  .option('-r, --rpre <redis pre>', 'administration user name', DEFAULT_REDIS_PRE)
  .option('-p, --password <password>', 'administration password', DEFAULT_PWD)
  .option('-h, --host <master-host>', 'master server host', DEFAULT_MASTER_HOST)
  .option('-P, --port <master-port>', 'master server port', DEFAULT_MASTER_PORT)
  .action(function() {
    let args = [].slice.call(arguments, 0);
    let opts = args[args.length - 1];
    opts.serverIds = args.slice(0, -1);
    terminal('stop', opts);
  });

program.command('kill')
  .description('kill the application')
  .option('-e, --env <env>', 'the used environment', DEFAULT_ENV)
  .option('-r, --rpre <redis pre>', 'administration user name', DEFAULT_REDIS_PRE)
  .option('-p, --password <password>', 'administration password', DEFAULT_PWD)
  .option('-h, --host <master-host>', 'master server host', DEFAULT_MASTER_HOST)
  .option('-P, --port <master-port>', 'master server port', DEFAULT_MASTER_PORT)
  .option('-f, --force', 'using this option would kill all the node processes')
  .action(function() {
    let args = [].slice.call(arguments, 0);
    let opts = args[args.length - 1];
    opts.serverIds = args.slice(0, -1);
    terminal('kill', opts);
  });


program.command('*')
  .action(function() {
    console.log(COMMAND_ERROR);
  });

program.parse(process.argv);

/**
 * Init application at the given directory `path`.
 *
 * @param {String} path
 */
function init(path) {
  console.log(INIT_PROJ_NOTICE);
  connectorType(function(type) {
    emptyDirectory(path, function(empty) {
      if(empty) {
        process.stdin.destroy();
        createApplicationAt(path, type);
      } else {
        confirm('Destination is not empty, continue? (y/n) [no] ', function(force) {
          process.stdin.destroy();
          if(force) {
            createApplicationAt(path, type);
          } else {
            abort('Fail to init a project'.red);
          }
        });
      }
    });
  });
}

/**
 * Create directory and files at the given directory `path`.
 *
 * @param {String} ph
 */
function createApplicationAt(ph, type) {
  let name = path.basename(path.resolve(CUR_DIR, ph));
  copy(path.join(__dirname, '../template/'), ph);
  mkdir(path.join(ph, 'game-server/logs'));
  mkdir(path.join(ph, 'shared'));
  // rmdir -r
  let rmdir = function(dir) {
    let list = fs.readdirSync(dir);
    for(let i = 0; i < list.length; i++) {
      let filename = path.join(dir, list[i]);
      let stat = fs.statSync(filename);
      if(filename === "." || filename === "..") {
      } else if(stat.isDirectory()) {
        rmdir(filename);
      } else {
        fs.unlinkSync(filename);
      }
    }
    fs.rmdirSync(dir);
  };
  setTimeout(function() {
    switch(type) {
      case '1':{
         // use websocket
         let unlinkFiles = ['game-server/app.js.sio',
         'game-server/app.js.wss',
         'game-server/app.js.mqtt',
         'game-server/app.js.sio.wss',
         'game-server/app.js.udp',
         'web-server/app.js.https',
         'web-server/public/index.html.sio',
         'web-server/public/js/lib/pomeloclient.js',
         'web-server/public/js/lib/pomeloclient.js.wss',
         'web-server/public/js/lib/build/build.js.wss',
         'web-server/public/js/lib/socket.io.js'];
         for(let i = 0; i < unlinkFiles.length; ++i) {
            fs.unlinkSync(path.resolve(ph, unlinkFiles[i]));
         }
        }break;
        case '2':{
          // use socket.io
          let unlinkFiles = ['game-server/app.js',
          'game-server/app.js.wss',
          'game-server/app.js.udp',
          'game-server/app.js.mqtt',
          'game-server/app.js.sio.wss',
          'web-server/app.js.https',
          'web-server/public/index.html',
          'web-server/public/js/lib/component.json',
          'web-server/public/js/lib/pomeloclient.js.wss'];
          for(let i = 0; i < unlinkFiles.length; ++i) {
            fs.unlinkSync(path.resolve(ph, unlinkFiles[i]));
          }

          fs.renameSync(path.resolve(ph, 'game-server/app.js.sio'), path.resolve(ph, 'game-server/app.js'));
          fs.renameSync(path.resolve(ph, 'web-server/public/index.html.sio'), path.resolve(ph, 'web-server/public/index.html'));

          rmdir(path.resolve(ph, 'web-server/public/js/lib/build'));
          rmdir(path.resolve(ph, 'web-server/public/js/lib/local'));
        }break;
        case '3':{
          // use websocket wss
          let unlinkFiles = ['game-server/app.js.sio',
          'game-server/app.js',
          'game-server/app.js.udp',
          'game-server/app.js.sio.wss',
          'game-server/app.js.mqtt',
          'web-server/app.js',
          'web-server/public/index.html.sio',
          'web-server/public/js/lib/pomeloclient.js',
          'web-server/public/js/lib/pomeloclient.js.wss',
          'web-server/public/js/lib/build/build.js',
          'web-server/public/js/lib/socket.io.js'];
          for(let i = 0; i < unlinkFiles.length; ++i) {
            fs.unlinkSync(path.resolve(ph, unlinkFiles[i]));
          }

          fs.renameSync(path.resolve(ph, 'game-server/app.js.wss'), path.resolve(ph, 'game-server/app.js'));
          fs.renameSync(path.resolve(ph, 'web-server/app.js.https'), path.resolve(ph, 'web-server/app.js'));
          fs.renameSync(path.resolve(ph, 'web-server/public/js/lib/build/build.js.wss'), path.resolve(ph, 'web-server/public/js/lib/build/build.js'));
        }break;
        case '4':{
          // use socket.io wss
           let unlinkFiles = ['game-server/app.js.sio',
          'game-server/app.js',
          'game-server/app.js.udp',
          'game-server/app.js.wss',
          'game-server/app.js.mqtt',
          'web-server/app.js',
          'web-server/public/index.html',
          'web-server/public/js/lib/pomeloclient.js'];
          for(let i = 0; i < unlinkFiles.length; ++i) {
            fs.unlinkSync(path.resolve(ph, unlinkFiles[i]));
          }

          fs.renameSync(path.resolve(ph, 'game-server/app.js.sio.wss'), path.resolve(ph, 'game-server/app.js'));
          fs.renameSync(path.resolve(ph, 'web-server/app.js.https'), path.resolve(ph, 'web-server/app.js'));
          fs.renameSync(path.resolve(ph, 'web-server/public/index.html.sio'), path.resolve(ph, 'web-server/public/index.html'));
          fs.renameSync(path.resolve(ph, 'web-server/public/js/lib/pomeloclient.js.wss'), path.resolve(ph, 'web-server/public/js/lib/pomeloclient.js'));

          rmdir(path.resolve(ph, 'web-server/public/js/lib/build'));
          rmdir(path.resolve(ph, 'web-server/public/js/lib/local'));
          fs.unlinkSync(path.resolve(ph, 'web-server/public/js/lib/component.json'));
        }break;
        case '5':{
          // use socket.io wss
           let unlinkFiles = ['game-server/app.js.sio',
          'game-server/app.js',
          'game-server/app.js.wss',
          'game-server/app.js.mqtt',
          'game-server/app.js.sio.wss',
          'web-server/app.js.https',
          'web-server/public/index.html',
          'web-server/public/js/lib/component.json',
          'web-server/public/js/lib/pomeloclient.js.wss'];
          for(let i = 0; i < unlinkFiles.length; ++i) {
            fs.unlinkSync(path.resolve(ph, unlinkFiles[i]));
          }
          
          fs.renameSync(path.resolve(ph, 'game-server/app.js.udp'), path.resolve(ph, 'game-server/app.js'));
          rmdir(path.resolve(ph, 'web-server/public/js/lib/build'));
          rmdir(path.resolve(ph, 'web-server/public/js/lib/local'));
        }break;
        case '6':{
          // use socket.io
          let unlinkFiles = ['game-server/app.js',
          'game-server/app.js.wss',
          'game-server/app.js.udp',
          'game-server/app.js.sio',
          'game-server/app.js.sio.wss',
          'web-server/app.js.https',
          'web-server/public/index.html',
          'web-server/public/js/lib/component.json',
          'web-server/public/js/lib/pomeloclient.js.wss'];
          for(let i = 0; i < unlinkFiles.length; ++i) {
            fs.unlinkSync(path.resolve(ph, unlinkFiles[i]));
          }

          fs.renameSync(path.resolve(ph, 'game-server/app.js.mqtt'), path.resolve(ph, 'game-server/app.js'));
          fs.renameSync(path.resolve(ph, 'web-server/public/index.html.sio'), path.resolve(ph, 'web-server/public/index.html'));

          rmdir(path.resolve(ph, 'web-server/public/js/lib/build'));
          rmdir(path.resolve(ph, 'web-server/public/js/lib/local'));
        }break;
        }
        let replaceFiles = ['game-server/app.js',
        'game-server/package.json',
        'web-server/package.json'];
        for(let j = 0; j < replaceFiles.length; j++) {
          let str = fs.readFileSync(path.resolve(ph, replaceFiles[j])).toString();
          fs.writeFileSync(path.resolve(ph, replaceFiles[j]), str.replace('$', name));
        }
        let f = path.resolve(ph, 'game-server/package.json');
        let content = fs.readFileSync(f).toString();
        fs.writeFileSync(f, content.replace('#', version));
      }, TIME_INIT);
}


/**
 * Start application.
 *
 * @param {Object} opts options for `start` operation
 */
function start(opts) {
  //opts.directory = '/home/shudingbo/work/serm/game-server';
  let absScript = path.resolve(opts.directory, 'app.js');

  if (!fs.existsSync(absScript)) {
    abort(SCRIPT_NOT_FOUND);
  }

  let logDir = path.resolve(opts.directory, 'logs');
  if (!fs.existsSync(logDir)) {
    fs.mkdirSync(logDir);
  }

  let type = opts.type || constants.RESERVED.ALL;
  let serversMapPath =  path.resolve(opts.directory, 'config/servers.json');
  let serversMap = JSON.parse(fs.readFileSync(serversMapPath, 'utf-8'))[opts.env];
  let runServers = {};
  if( type === constants.RESERVED.ALL ){
    runServers = serversMap;
  }else{
    runServers[type] = serversMap[type];
  }
  
  let runSersReal = [];
  for(let serType in runServers)
  {
    let typeHasSer = runServers[serType];
    let serLen = typeHasSer.length;
    for( let j=0;j<serLen;j++ ){
        let params = {
          "env" :opts.env,
          "serverType": serType
        }

        let serInfo = typeHasSer[j];
        let bParamOK = true;
        if( (serInfo.id != undefined)){
          params['id']   = serInfo.id;
          params['host'] = serInfo.host;

          if(serInfo.port != undefined){
            params['port'] = serInfo.port;
          }
          if( serInfo.frontend === true){
            if( serInfo.clientPort != undefined )
            {
                params['frontend'] = 'true';
                params['clientPort'] = serInfo.clientPort;
            }else{
              bParamOK = false;
            }
          }else{
            params['frontend']='false';
          }
        }else{
          bParamOK = false;
        }

        if( bParamOK ){
          let par= { "runScript":absScript, "par":params,"cwd":opts.directory };
          runSersReal.push( par );
        }
    }
  }

  for( let i of runSersReal ){
    runServer( i );
  }
}

/**
 * List pomelo processes.
 *
 * @param {Object} opts options for `list` operation
 */
function list(opts) {
  connectToMaster(opts, function(client) {
    let keyRegPre = `${opts.rpre}-reg:${opts.env}`;
    let keySerPre = `${opts.rpre}-ser:${opts.env}:`;
    (async()=>{
      try{
        let query_args = [keyRegPre, Date.now(), '+inf'];
        let res = await client.zrangebyscore( query_args );

        if(res instanceof Array && res.length > 0 ){
          for( let i=0; i<res.length;i++){
            res[i] = keySerPre + res[i];
          }
          let sers = await client.mget( res );
          
          let servers = [];
          for( let it of sers ){
            let info = JSON.parse( it );
            servers.push(info);
          }
          
          let comparer = function(a, b) {
            if (a.serverType < b.serverType) {
              return -1;
            } else if (a.serverType > b.serverType) {
              return 1;
            } else if (a.serverId < b.serverId) {
              return -1;
            } else if (a.serverId > b.serverId) {
              return 1;
            } else {
              return 0;
            }
          };
          servers.sort(comparer);
          let rows = [];
          rows.push(['serverId', 'serverType', 'pid','host', 'rss(M)', 'heap(M)', 'uptime(m)']);
          servers.forEach(function(server) {
            let uptime = server.uptime;
            let rss = server.rss || 0;
            let heapTotal = server.heapTotal || 0;
            let heapUsed = server.heapUsed || 0;

            rows.push([server.serverId, server.serverType, server.pid, server.host,rss, heapUsed +"/" +heapTotal, uptime]);
          });
          console.log(cliff.stringifyRows(rows, ['red', 'blue', 'green','cyan', 'magenta', 'white', 'yellow']));
        }
        ///////////////////////
        client.quit();
        process.exit(0);

      }catch( err ){
        console.log( err );
        client.quit();
        process.exit(0);
      }
    })();
  });
}

/**
 * Add server to application.
 *
 * @param {Object} opts options for `add` operation
 */
function add(opts) {

  let absScript = path.resolve(opts.directory, 'app.js');
  if (!fs.existsSync(absScript)) {
    abort(SCRIPT_NOT_FOUND);
  }

  let logDir = path.resolve(opts.directory, 'logs');
  if (!fs.existsSync(logDir)) {
    fs.mkdirSync(logDir);
  }

  let params = {
    "env" :opts.env
  }

  for( let it of opts.args ){
    let parArr = it.split('=');
    params[ parArr[0] ] = parArr[1];
  }

  let par= { "runScript":absScript, "par":params,"cwd":opts.directory };
  runServer( par, (msg) =>{
    console.log( params.id + ":"+ msg);
  });

  if( opts.env === 'production' ){
    process.exit(0);
  }
}

function array_uniquelize( srArr){  
    let ra = [];  
    for(let i = 0; i < srArr.length; i ++){  
        if(!ra.includes(srArr[i])){  
          ra.push(srArr[i]);  
        }  
    }  
    return ra;  
};

function array_intersection(a, b) {
  let result = [];
  for(let i = 0; i < b.length; i ++) {
      let temp = b[i];
      for(let j = 0; j < a.length; j ++) {
          if(temp === a[j]) {
              result.push(temp);
              break;
          }
      }
  }
  return array_uniquelize(result);
}


function sex_timeout(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

/**
 * Terminal application.
 *
 * @param {String} signal stop/kill
 * @param {Object} opts options for `stop/kill` operation
 */
function terminal(signal, opts) {
  console.info(CLOSEAPP_INFO);
  // option force just for `kill`
  if(opts.force) {
    if (os.platform() === constants.PLATFORM.WIN) {
      exec(KILL_CMD_WIN);
    } else {
      exec(KILL_CMD_LUX);
    }
    process.exit(1);
    return;
  }

  ////////////////////
  connectToMaster(opts, function(client) {
    let keyRegPre = `${opts.rpre}-reg:${opts.env}`;
    let keySerPre = `${opts.rpre}-ser:${opts.env}:`;
    (async()=>{
      try{
        let query_args = [keyRegPre, Date.now(), '+inf'];
        let res = await client.zrangebyscore( query_args );
        let serverIds = res;
        if( opts.serverIds.length > 0 ){
          serverIds = array_intersection( res, opts.serverIds);
        }
        
        if(serverIds.length > 0 ){
          let keySers = [];
          for( let i=0; i<serverIds.length;i++){
            keySers.push( keySerPre + serverIds[i] );
          }
          let sers = await client.mget( keySers );
          
          let servers = [];
          for( let it of sers ){
            let info = JSON.parse( it );
            info.frontend = (info.frontend=='true')?1:0;
            servers.push(info);
          }
          
          let comparer = function(a, b) {
            if (a.frontend < b.frontend) {
              return 1;
            }else{
              if (a.serverType > b.serverType) {
                return 1;
              } else if (a.serverId < b.serverId) {
                return -1;
              } else if (a.serverId > b.serverId) {
                return 1;
              } 
              return 0;
            }
          };
          servers.sort(comparer);
          //////////// Send Stop Cmd
          let cmd = `{"command":"${signal}"}`;
          let stopData = {};
          let retKeys = [];
          for( let ser of servers ){
            console.log(`i ${ser.serverId} now stoping...`);
            let keySerId = keyRegPre + ":" + ser.serverId;
            stopData[keySerId] = cmd;
            retKeys.push( keySerId );
          }

          await client.mset( stopData );

          if( signal === 'stop' ){
            let checkCnt = 0;
            let bExits = [];
            let wastTime = 0;
            while(1){
              await sex_timeout( 2000 );
              console.log(`wait stop ... [${checkCnt}]s`);
              bExits = await client.mget( retKeys );
              let allExit = true;
              let retKeysTmp = [];
              for( let i=0;i<bExits.length; i++ ){
                  if( bExits[i] !== null){
                      allExit = false;
                      retKeysTmp.push(retKeys[i]);
                  }else{
                    console.log(`i ${retKeys[i]} now stop ok.`);
                  }
              }

              if( allExit ){
                break;
              }

              checkCnt += 2;
              if(checkCnt >= 90){
                break;
              }
            }

            if( checkCnt >= 60 ){
              for( let i=0;i<bExits.length; i++ ){
                  if( bExits[i] !== null){
                      allExit = false;
                      console.log(`x ${retKeys[i]} stop err.`);
                  }
              }
            }else{
              console.log(`o all stop OK`);
            }                
          }
        }
        ///////////////////////
        client.quit();
        process.exit(0);

      }catch( err ){
        console.log( err );
        client.quit();
        process.exit(0);
      }
    })();
  });
}



function connectToMaster( opts, cb) {
  let connInfo = {
    "port":opts.port,
    "host":opts.host
  };

  if( opts.password != undefined ){
    connInfo.password = opts.password;
  }


  let client = new redis(connInfo);
  client.on("ready",function( err ){
    cb( client,"reday" );
  });

  client.on("error",function( err ){
    console.error( err);
    cb( null, err );
  });
}


/**
 * Check if the given directory `path` is empty.
 *
 * @param {String} path
 * @param {Function} fn
 */
function emptyDirectory(path, fn) {
  fs.readdir(path, function(err, files) {
    if(err && 'ENOENT' !== err.code) {
      abort(FILEREAD_ERROR);
    }
    fn(!files || !files.length);
  });
}

/**
 * Prompt confirmation with the given `msg`.
 *
 * @param {String} msg
 * @param {Function} fn
 */
function confirm(msg, fn) {
  prompt(msg, function(val) {
    fn(/^ *y(es)?/i.test(val));
  });
}

/**
 * Prompt input with the given `msg` and callback `fn`.
 *
 * @param {String} msg
 * @param {Function} fn
 */
function prompt(msg, fn) {
  if(' ' === msg[msg.length - 1]) {
    process.stdout.write(msg);
  } else {
    console.log(msg);
  }
  process.stdin.setEncoding('ascii');
  process.stdin.once('data', function(data) {
    fn(data);
  }).resume();
}

/**
 * Exit with the given `str`.
 *
 * @param {String} str
 */
function abort(str) {
  console.error(str);
  process.exit(1);
}

/**
 * Copy template files to project.
 *
 * @param {String} origin
 * @param {String} target
 */
function copy(origin, target) {
  if(!fs.existsSync(origin)) {
    abort(origin + 'does not exist.');
  }
  if(!fs.existsSync(target)) {
    mkdir(target);
    console.log('   create : '.green + target);
  }
  fs.readdir(origin, function(err, datalist) {
    if(err) {
      abort(FILEREAD_ERROR);
    }
    for(let i = 0; i < datalist.length; i++) {
      let oCurrent = path.resolve(origin, datalist[i]);
      let tCurrent = path.resolve(target, datalist[i]);
      if(fs.statSync(oCurrent).isFile()) {
        fs.writeFileSync(tCurrent, fs.readFileSync(oCurrent, ''), '');
        console.log('   create : '.green + tCurrent);
      } else if(fs.statSync(oCurrent).isDirectory()) {
        copy(oCurrent, tCurrent);
      }
    }
  });
}

/**
 * Mkdir -p.
 *
 * @param {String} path
 * @param {Function} fn
 */
function mkdir(path, fn) {
  mkdirp(path, 0755, function(err){
    if(err) {
      throw err;
    }
    console.log('   create : '.green + path);
    if(typeof fn === 'function') {
      fn();
    }
  });
}

/**
 * Get user's choice on connector selecting
 * 
 * @param {Function} cb
 */
function connectorType(cb) {
  prompt('Please select underly connector, 1 for websocket(native socket), 2 for socket.io, 3 for wss, 4 for socket.io(wss), 5 for udp, 6 for mqtt: [1]', function(msg) {
    switch(msg.trim()) {
      case '':
         cb(1);
         break;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
         cb(msg.trim());
         break;
      default:
         console.log('Invalid choice! Please input 1 - 5.'.red + '\n');
         connectorType(cb);
         break;
    }
  });
}

/**
 * Run server.
 * 
 * @param {Object} server server information
 */
function runServer(server, cb) {
  starter.setEnv( server.par.env );

  let cmd, key;
  if(utils.isLocal(server.par.host)) {

    let options = [];
    options.push( server.runScript);
    for(key in server.par) {
      options.push(util.format('%s=%s', key, server.par[key]));
    }
    starter.localrun(process.execPath, null, options,cb);
  } else {
    cmd = util.format('cd "%s" && "%s"', server.cwd, process.execPath);
    cmd += util.format(' "%s" ', server.runScript);

    for(key in server.par) {
      cmd += util.format('%s=%s ', key, server.par[key]);
    }

    starter.sshrun(cmd, server.par.host,cb);
  }
}